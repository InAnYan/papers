# Слайд №1
Добрий день! Мене звати Руслан Попов, і я вам хочу презентувати нашу статтю на тему “…”.
Наше дослідження торкається теорії мов програмування та розробки компіляторів, і пропонує новий метод реалізації патерну Відвідувач у мові С++, який є швидким у написанні та надає багато цікавих можливостей.

# Слайд №2
Почнемо з того, у компіляторів та інтерпретаторів є спільна стадія обробки програми — це парсинг. Необхідно трансформувати текст програми у проміжну репрезентацію, яка називається дерево абстрактного синтаксису. Це такий рекурсивний тип даних, який виокремлює синтаксис програми з послідовності символів і який є дуже зручним у подальшій обробці вихідного коду.

# Слайд №3
Маючи таке дерево, ми можемо робити з ним багато речей. Наприклад: для дебагінгу корисно роздрукувати дерево на консоль, результатом чого буде символьний рядок; інтерпретатор може обчислити вираз, результатом чого буде певне значення; або оптимізатор може перетворити дерево на інше. Під час розробки компіляторів постає задача закодувати дерево абстрактного синтаксису таким чином, щоб можна було швидко додавати функції для обробки цього дерева. Ця задача у зарубіжній літературі має назву “expression problem”.

# Слайд №4
Оскільки С++ - це мова об’єктно-орієнтованого програмування, тому природньо буде представити вузли дерева як класи, а функції над цим деревом як методи класу. Тобто необхідно створити інтерфейс вузла, в якому будуть віртуальні методи, а кожен вузол ДАС реалізує їх по-своєму. Такий спосіб гарно працює та збігається з парадигмою ООП, але у нього є певний недолік. Він полягає в тому, що різні функції роботи над деревом перемішені в одному класі. І таке спостереження підштовхує на питання: чи можна конкретні функції обробки вузла писати в одному вихідному файлі?

# Слайд №5
Класичним способом розв’язання проблеми “expression problem” у мовах об’єктно-орієнтованого програмування є використання патерну Visitor. У цьому патерні ми розподіляємо увесь код на два класи: перші це класи для вузлів дерева, а інші це класи, які оброблюють це дерево. Створюється інтерфейс відвідувач, який повинні реалізувати усі класи, якім необхідно доступ до дерева. У кожного вузла має бути реалізований метод “accept”, який приймає об’єкт типу відвідувач та викликає у нього відповідний метод “visit”.

# Слайд №6
Такий підхід повністю вирішує “expression problem”, але він також має свої недоліки. Він не є простим для розуміння, необхідно чітко уявляти архітектуру програми та як програма буде виконуватися. Цей патерн є доволі складним у написанні. Якщо виникає потреба створити новий вузол ДАС, необхідно створити віртуальний метод visit у відвідувача, а у нового вузла треба реалізувати метод accept. Ми поставилися питанням: чи можна цей патерн відтворити легше?

# Слайд №7
Занурившись у стандарт С++ ми віднайшли такий контейнер як std::variant та функцію std::visit. Std::variant — це сучасна типово-безпечна реалізація об’єднання в С++. Він є стандартним контейнером та використовує можливості шаблонного метапрограмування. Якщо раніше доступ до змінних компонентів відбувався через використання методів для перевірки збереженого типу і прямого доступу до елемента об’єднання, то std::variant пропонує більш цікавий спосіб.

# Слайд №8
Є така функція як std::visit. Вона приймає два аргументи: перший — це Callable об’єкт, який називається відвідувачем, а другий — це варіант. У відвідувачі повинні бути визначені функції виклику з усіма типами даних, які збережені у варіанті. Std::visit буде дивитися на елемент, який є збереженим, та викликатиме необхідний метод у відвідувачі для обробки типу. На цьому слайді наведений приклад коду. Ми створили клас, в якому визначені методи для роботи с цілим числом та булевим значенням. Всередині функції main ми створили variant, який зберігає ціле число та булеве значення. Ми також створили екземпляр відвідувача і, таким чином, можемо викликати метод std::visit, який поверне символьний рядок відповідно до типу, який він зберігає.

# Слайд №9
Наш метод розв’язання “expression problem” полягає у використанні цього контейнеру. Абстрактні вузли дерева абстрактного синтаксису можна представити як варіант. А певний функціонал над деревом так і залишається окремим класом, у якому методи обробки дерева повинні мати одну і ту саму назву, але мати різний тип параметру. Перевагою запропонованого способу є те, що він усуне потребу створення інтерфейсу Visitor та створення методів accept у вузлах дерева. Це зменшує час на створення коду та є більш легким у розумінні. Але найбільшою перевагою є те, що відвідувачі можуть повертати будь-який тип даних. Річ у тому, що в класичному способі реалізації відвідувач — це абстрактний клас, і методи visit є віртуальними, а отже їх не можна обернути у шаблон і вони так і мають залишатися void. Оптимізатор не може повернути нове дерево, інтерпретатор не може повернути результат обчислень, тому вони вимушені зберігати усі результати у полі свого класу. Але, використовуючи метод std::visit, ця проблема вирішена.

# Слайд №10
У цього методу є декілька недоліків, на які слід звернути увагу перед використанням. По-перше, std::variant доступний лише зі стандарту С++17. По-друге, std::variant реалізований за допомогою шаблонного метапрограмування, тому компілятор, у разі яких-небудь помилок у коді, може видавати дивні та складні повідомлення про помилки. По-третє, треба бути обережним при створенні вузлів ДАС, не можна прямо використовувати std::variant усередені вузла, оскільки виникне класична проблема використання структури усередині самої себе.

# Слайд №11
Таким чином, ми показали як за допомогою std::variant можна закодувати ДАС та відтворити патерн Відвідувач. Наш метод відрізняється швидкістю та багатофункціональністю у порівнянні з класичною реалізацією Visitor. Це пришвидшить створення нових інтерпретаторів і компіляторів. Також ми хочемо відмітити, що наш спосіб є універсальним і підходить до всіх проблем, у яких задіяний тип суми.

# Слайд №12
На цьому все, дякую за увагу!

